"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.animationHelpers = void 0;
var AnimationFiniteStateMachine_1 = require("../../../../Core/Animations/AnimationFiniteStateMachine");
var PointMarkerType_1 = require("../../../../types/PointMarkerType");
var colorUtil_1 = require("../../../../utils/colorUtil");
var IDataSeries_1 = require("../../../Model/IDataSeries");
var CrossPointMarker_1 = require("../../PointMarkers/CrossPointMarker");
var EllipsePointMarker_1 = require("../../PointMarkers/EllipsePointMarker");
var SpritePointMarker_1 = require("../../PointMarkers/SpritePointMarker");
var SquarePointMarker_1 = require("../../PointMarkers/SquarePointMarker");
var TrianglePointMarker_1 = require("../../PointMarkers/TrianglePointMarker");
var XPointMarker_1 = require("../../PointMarkers/XPointMarker");
/**
 * Checks if can draw, is used not to draw when {@link BaseAnimation} has delay
 * @param animationFSM
 */
var checkCanDraw = function (animationFSM) {
    return animationFSM ? animationFSM.is([AnimationFiniteStateMachine_1.EAnimationState.Running, AnimationFiniteStateMachine_1.EAnimationState.Completed]) : true;
};
/**
 * Checks if the animation is running
 * @param animationQueue The animation queue
 * @param animationFSM The animation finate state machine
 */
var checkIsAnimationRunning = function (animationQueue, animationFSM) {
    if (animationQueue.length > 0) {
        return true;
    }
    if (!animationFSM) {
        return false;
    }
    return !animationFSM.is([AnimationFiniteStateMachine_1.EAnimationState.Completed]);
};
/**
 * Runs update for the animation
 * @param animationFSM
 * @param timeElapsed
 * @param beforeAnimationStart
 * @param afterAnimationComplete
 * @param updateAnimationProperties
 */
var animationUpdate = function (animationFSM, timeElapsed, beforeAnimationStart, afterAnimationComplete, updateAnimationProperties) {
    var transition = animationFSM.update(timeElapsed);
    if ([AnimationFiniteStateMachine_1.EAnimationStateTransition.InitialState_Running, AnimationFiniteStateMachine_1.EAnimationStateTransition.Delayed_Running].includes(transition)) {
        beforeAnimationStart();
    }
    if (animationFSM.is([AnimationFiniteStateMachine_1.EAnimationState.Running, AnimationFiniteStateMachine_1.EAnimationState.Completed])) {
        updateAnimationProperties(animationFSM.animationProgress, animationFSM);
    }
    if (transition === AnimationFiniteStateMachine_1.EAnimationStateTransition.Running_Completed) {
        afterAnimationComplete();
    }
};
/**
 * Creates the point marker
 * @param wasmContext
 * @param pointMarkerStyle
 */
var createPointMarker = function (wasmContext, pointMarkerStyle) {
    if (!pointMarkerStyle)
        return undefined;
    if (pointMarkerStyle.type === PointMarkerType_1.EPointMarkerType.Sprite) {
        var _a = pointMarkerStyle, type = _a.type, options = __rest(_a, ["type"]);
        return new SpritePointMarker_1.SpritePointMarker(wasmContext, __assign({}, options));
    }
    else {
        var _b = pointMarkerStyle, type = _b.type, options = __rest(_b, ["type"]);
        switch (type) {
            case PointMarkerType_1.EPointMarkerType.Cross:
                return new CrossPointMarker_1.CrossPointMarker(wasmContext, __assign({}, options));
            case PointMarkerType_1.EPointMarkerType.Ellipse:
                return new EllipsePointMarker_1.EllipsePointMarker(wasmContext, __assign({}, options));
            case PointMarkerType_1.EPointMarkerType.X:
                return new XPointMarker_1.XPointMarker(wasmContext, __assign({}, options));
            case PointMarkerType_1.EPointMarkerType.Square:
                return new SquarePointMarker_1.SquarePointMarker(wasmContext, __assign({}, options));
            case PointMarkerType_1.EPointMarkerType.Triangle:
                return new TrianglePointMarker_1.TrianglePointMarker(wasmContext, __assign({}, options));
        }
    }
    return undefined;
};
/**
 * Interpolates numbers
 * @param from
 * @param to
 * @param progress
 */
var interpolateNumber = function (from, to, progress) {
    if (progress < 0)
        return from;
    if (progress > 1)
        return to;
    return from + (to - from) * progress;
};
/**
 * Interpolates colors
 * @param from
 * @param to
 * @param progress
 */
var interpolateColor = function (from, to, progress) {
    if (progress < 0)
        return from;
    if (progress > 1)
        return to;
    return (0, colorUtil_1.uintArgbColorLerp)(from, to, progress);
};
var copyVector = function (sourceVector, targetVector) {
    var size = sourceVector.size();
    targetVector.resize(size, 0);
    for (var i = 0; i < size; i++) {
        targetVector.set(i, sourceVector.get(i));
    }
};
var setSplineAnimationVectors = function (wasmContext, animation, ds, animationDS, xSplineValues, ySplineValues, isCategoryAxis, interpolationPoints) {
    if (animation.isOnStartAnimation) {
        // animationHelpers.copyVector(xSplineValues, ds.xFinalAnimationValues);
        exports.animationHelpers.copyVector(ySplineValues, ds.yFinalAnimationValues);
    }
    else if (animation.isDataSeriesAnimation) {
        exports.animationHelpers.copyVector(xSplineValues, ds.xInitialAnimationValues);
        exports.animationHelpers.copyVector(ySplineValues, ds.yInitialAnimationValues);
        // set final animation values for the spline
        var dataSeries = animation.dataSeries;
        var xValues = isCategoryAxis ? dataSeries.getNativeIndexes() : dataSeries.getNativeXValues();
        wasmContext.SCRTSplineHelperCubicSpline(xValues, dataSeries.getNativeYValues(), ds.xFinalAnimationValues, ds.yFinalAnimationValues, xValues.size(), interpolationPoints, dataSeries.dataDistributionCalculator.containsNaN);
    }
};
var setSplineBandAnimationVectors = function (wasmContext, animation, ds, animationDS, xSplineValues, ySplineValues, y1SplineValues, isCategoryAxis, interpolationPoints) {
    exports.animationHelpers.setSplineAnimationVectors(wasmContext, animation, ds, animationDS, xSplineValues, ySplineValues, isCategoryAxis, interpolationPoints);
    if (animation.isOnStartAnimation) {
        exports.animationHelpers.copyVector(y1SplineValues, ds.y1FinalAnimationValues);
    }
    else if (animation.isDataSeriesAnimation) {
        if (animationDS.type !== IDataSeries_1.EDataSeriesType.Xyy) {
            throw Error("to animate band chart animation.dataSeries type should be Xyy, but the type is ".concat(animationDS.type));
        }
        exports.animationHelpers.copyVector(y1SplineValues, ds.y1InitialAnimationValues);
        // set final animation values for the spline
        var xValues = isCategoryAxis ? animationDS.getNativeIndexes() : animationDS.getNativeXValues();
        wasmContext.SCRTSplineHelperCubicSpline(xValues, animationDS.getNativeY1Values(), ds.xFinalAnimationValues, ds.y1FinalAnimationValues, xValues.size(), interpolationPoints, animationDS.dataDistributionCalculator.containsNaN);
        ds.validateAnimationVectors();
    }
};
var updateSplineAnimationProperties = function (wasmContext, animation, progress, dataSeries, xSplineValues, ySplineValues) {
    if (animation.isOnStartAnimation) {
        animation.calculateAnimationValues(wasmContext, dataSeries.yFinalAnimationValues, ySplineValues, progress);
    }
    else if (animation.isDataSeriesAnimation) {
        animation.calculateDataSeriesAnimationValues(wasmContext, dataSeries.xInitialAnimationValues, dataSeries.xFinalAnimationValues, xSplineValues, progress);
        animation.calculateDataSeriesAnimationValues(wasmContext, dataSeries.yInitialAnimationValues, dataSeries.yFinalAnimationValues, ySplineValues, progress);
    }
};
var updateSplineBandAnimationProperties = function (wasmContext, animation, progress, dataSeries, xSplineValues, ySplineValues, y1SplineValues) {
    exports.animationHelpers.updateSplineAnimationProperties(wasmContext, animation, progress, dataSeries, xSplineValues, ySplineValues);
    if (animation.isOnStartAnimation) {
        animation.calculateAnimationValues(wasmContext, dataSeries.y1FinalAnimationValues, y1SplineValues, progress);
    }
    else if (animation.isDataSeriesAnimation) {
        animation.calculateDataSeriesAnimationValues(wasmContext, dataSeries.y1InitialAnimationValues, dataSeries.y1FinalAnimationValues, y1SplineValues, progress);
    }
};
exports.animationHelpers = {
    checkCanDraw: checkCanDraw,
    checkIsAnimationRunning: checkIsAnimationRunning,
    animationUpdate: animationUpdate,
    createPointMarker: createPointMarker,
    interpolateNumber: interpolateNumber,
    interpolateColor: interpolateColor,
    copyVector: copyVector,
    setSplineAnimationVectors: setSplineAnimationVectors,
    setSplineBandAnimationVectors: setSplineBandAnimationVectors,
    updateSplineAnimationProperties: updateSplineAnimationProperties,
    updateSplineBandAnimationProperties: updateSplineBandAnimationProperties
};
