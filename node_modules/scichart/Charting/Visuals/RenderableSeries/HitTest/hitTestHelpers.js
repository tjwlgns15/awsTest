"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hitTestHelpers = void 0;
var Point_1 = require("../../../../Core/Point");
var ErrorDirection_1 = require("../../../../types/ErrorDirection");
var pointUtil_1 = require("../../../../utils/pointUtil");
var HitTestInfo_1 = require("./HitTestInfo");
var interpolateLinear = function (x, x1, y1, x2, y2) {
    return y1 + ((y2 - y1) * (x - x1)) / (x2 - x1);
};
// TODO: take isVertical property into account
/**
 *
 * @param renderableSeries
 * @param xCoordinateCalculator
 * @param yCoordinateCalculator
 * @param isVerticalChart
 * @param dataSeries
 * @param xNativeValues
 * @param yNativeValues
 * @param xHitCoord the X coordinate on the screen relative to seriesViewRect, X and Y swapped for vertical charts
 * @param yHitCoord the Y coordinate on the screen relative to seriesViewRect, X and Y swapped for vertical charts
 * @param nearestPointIndex
 * @param hitTestRadius
 */
var createHitTestInfo = function (renderableSeries, xCoordinateCalculator, yCoordinateCalculator, isVerticalChart, dataSeries, xNativeValues, yNativeValues, xHitCoord, yHitCoord, nearestPointIndex, hitTestRadius) {
    var isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
    var hitTestInfo = new HitTestInfo_1.HitTestInfo(renderableSeries);
    hitTestInfo.dataSeriesName = dataSeries.dataSeriesName;
    hitTestInfo.dataSeriesType = dataSeries.type;
    hitTestInfo.hitTestPoint = new Point_1.Point(xHitCoord, yHitCoord);
    var hitTestPointXValue = xCoordinateCalculator.getDataValue(xHitCoord);
    var hitTestPointYValue = yCoordinateCalculator.getDataValue(yHitCoord);
    hitTestInfo.hitTestPointValues = new Point_1.Point(hitTestPointXValue, hitTestPointYValue);
    hitTestInfo.dataSeriesIndex = nearestPointIndex;
    hitTestInfo.hitTestRadius = hitTestRadius;
    hitTestInfo.isCategoryAxis = isCategoryAxis;
    // If there is no data, don't attempt to access it.
    if (nearestPointIndex >= 0) {
        var xValue = isCategoryAxis ? nearestPointIndex : xNativeValues.get(nearestPointIndex);
        var yValue = yNativeValues.get(nearestPointIndex);
        hitTestInfo.xCoord = xCoordinateCalculator.getCoordinate(xValue);
        hitTestInfo.yCoord = yCoordinateCalculator.getCoordinate(yValue);
        // TODO: It might be worth to flip them to make the API better
        // if (isVerticalChart) {
        //     const temp = hitTestInfo.xCoord;
        //     hitTestInfo.xCoord = hitTestInfo.yCoord;
        //     hitTestInfo.yCoord = temp;
        // }
        hitTestInfo.xValue = xValue;
        if (isCategoryAxis) {
            hitTestInfo.xCategoryValue = xNativeValues.get(nearestPointIndex);
        }
        hitTestInfo.yValue = yValue;
        var xFirstValue = isCategoryAxis ? 0 : xNativeValues.get(0);
        var xLastValue = isCategoryAxis ? xNativeValues.size() - 1 : xNativeValues.get(xNativeValues.size() - 1);
        if (!dataSeries.dataDistributionCalculator.isSortedAscending) {
            for (var i = 0; i < dataSeries.count(); i++) {
                if (xNativeValues.get(i) < xFirstValue) {
                    xFirstValue = xNativeValues.get(i);
                }
                if (xNativeValues.get(i) > xLastValue) {
                    xLastValue = xNativeValues.get(i);
                }
            }
        }
        hitTestInfo.isWithinDataBounds = (0, pointUtil_1.testIsInInterval)(hitTestPointXValue, xFirstValue, xLastValue);
        hitTestInfo.metadata = dataSeries.getMetadataAt(nearestPointIndex);
    }
    else {
        hitTestInfo.isWithinDataBounds = false;
    }
    hitTestInfo.isHit = undefined;
    return hitTestInfo;
};
var getNearestXPoint = function (webAssemblyContext, xCoordinateCalculator, dataSeries, xHitCoord, isSorted) {
    var xHitValue = xCoordinateCalculator.getDataValue(xHitCoord);
    var isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
    var xValues = isCategoryAxis ? dataSeries.getNativeIndexes() : dataSeries.getNativeXValues();
    if (isSorted) {
        return webAssemblyContext.NumberUtil.FindIndex(xValues, xHitValue, webAssemblyContext.SCRTFindIndexSearchMode.Nearest, isSorted);
    }
    // TODO check if could be refactored
    var dataLength = dataSeries.count();
    var nearestPointIndex = -1;
    var currentDistance = Number.MAX_VALUE;
    for (var i = 0; i < dataLength; i++) {
        var xValue = xValues.get(i);
        var distance = Math.abs(xHitValue - xValue);
        if (distance < currentDistance) {
            nearestPointIndex = i;
            currentDistance = distance;
        }
    }
    return nearestPointIndex;
};
var getNearestXyPoint = function (xCoordinateCalculator, yCoordinateCalculator, dataSeries, xHitCoord, yHitCoord) {
    var dataLength = dataSeries.count();
    // TODO: if isSorted
    var nearestPointIndex = -1;
    var currentDistance = Number.MAX_VALUE;
    var isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
    for (var i = 0; i < dataLength; i++) {
        var dataX = isCategoryAxis ? i : dataSeries.getNativeXValues().get(i);
        var dataY = dataSeries.getNativeYValues().get(i);
        var coordX = xCoordinateCalculator.getCoordinate(dataX);
        var coordY = yCoordinateCalculator.getCoordinate(dataY);
        var distance = (0, pointUtil_1.calcDistance)(xHitCoord, yHitCoord, coordX, coordY);
        if (distance < currentDistance) {
            nearestPointIndex = i;
            currentDistance = distance;
        }
    }
    return nearestPointIndex;
};
var getNearestXyyPoint = function (xCoordinateCalculator, yCoordinateCalculator, dataSeries, xHitCoord, yHitCoord) {
    var dataLength = dataSeries.count();
    // TODO: if isSorted
    var nearestPointIndex = -1;
    var currentDistance = Number.MAX_VALUE;
    var isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
    for (var i = 0; i < dataLength; i++) {
        var dataX = isCategoryAxis ? i : dataSeries.getNativeXValues().get(i);
        var dataY = dataSeries.getNativeYValues().get(i);
        var dataY1 = dataSeries.getNativeY1Values().get(i);
        var coordX = xCoordinateCalculator.getCoordinate(dataX);
        var coordY = yCoordinateCalculator.getCoordinate(dataY);
        var coordY1 = yCoordinateCalculator.getCoordinate(dataY1);
        var distance = (0, pointUtil_1.calcDistance)(xHitCoord, yHitCoord, coordX, coordY);
        var distance1 = (0, pointUtil_1.calcDistance)(xHitCoord, yHitCoord, coordX, coordY1);
        if (distance < currentDistance) {
            nearestPointIndex = i;
            currentDistance = distance;
        }
        if (distance1 < currentDistance) {
            nearestPointIndex = i;
            currentDistance = distance1;
        }
    }
    return nearestPointIndex;
};
var getNearestUniformHeatmapPoint = function (xCoordinateCalculator, yCoordinateCalculator, heatmapDataSeries, xHitCoord, yHitCoord) {
    var xHitValue = xCoordinateCalculator.getDataValue(xHitCoord);
    var yHitValue = yCoordinateCalculator.getDataValue(yHitCoord);
    var xIndex = Math.floor((xHitValue - heatmapDataSeries.xStart) / heatmapDataSeries.xStep);
    var yIndex = Math.floor((yHitValue - heatmapDataSeries.yStart) / heatmapDataSeries.yStep);
    if (xIndex < 0 || xIndex >= heatmapDataSeries.arrayWidth || yIndex < 0 || yIndex >= heatmapDataSeries.arrayHeight) {
        return { xIndex: -1, yIndex: -1, zValue: undefined };
    }
    var zValue = heatmapDataSeries.getZValue(yIndex, xIndex);
    return { xIndex: xIndex, yIndex: yIndex, zValue: zValue };
};
var getNearestNonUniformHeatmapPoint = function (xCoordinateCalculator, yCoordinateCalculator, heatmapDataSeries, xHitCoord, yHitCoord) {
    var xHitValue = xCoordinateCalculator.getDataValue(xHitCoord);
    var yHitValue = yCoordinateCalculator.getDataValue(yHitCoord);
    var xCellOffsets = heatmapDataSeries.xCellOffsets, yCellOffsets = heatmapDataSeries.yCellOffsets;
    var xIndex = -1;
    if (xHitValue >= xCellOffsets[0] && xHitValue <= xCellOffsets[xCellOffsets.length - 1]) {
        for (var i = 0; i < xCellOffsets.length; i++) {
            var isWithinCellOffsets = xHitValue >= xCellOffsets[i] && xHitValue <= xCellOffsets[i + 1];
            if (isWithinCellOffsets) {
                xIndex = i;
                break;
            }
        }
    }
    var yIndex = -1;
    if (yHitValue >= yCellOffsets[0] && yHitValue <= yCellOffsets[yCellOffsets.length - 1]) {
        for (var i = 0; i < yCellOffsets.length - 1; i++) {
            var isWithinCellOffsets = yHitValue >= yCellOffsets[i] && yHitValue <= yCellOffsets[i + 1];
            if (isWithinCellOffsets) {
                yIndex = i;
                break;
            }
        }
    }
    // TODO shouldn't we return a neerest cell anyway?
    if (xIndex < 0 || xIndex >= heatmapDataSeries.arrayWidth || yIndex < 0 || yIndex >= heatmapDataSeries.arrayHeight) {
        return { xIndex: -1, yIndex: -1, zValue: undefined };
    }
    var zValue = heatmapDataSeries.getZValue(yIndex, xIndex);
    return { xIndex: xIndex, yIndex: yIndex, zValue: zValue };
};
var testIsHitForPoint = function (xCoordinateCalculator, yCoordinateCalculator, xValues, yValues, pointIndex, xHitCoord, yHitCoord, hitTestRadius) {
    var isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
    var xValue = isCategoryAxis ? pointIndex : xValues.get(pointIndex);
    var yValue = yValues.get(pointIndex);
    var dataXCoord = xCoordinateCalculator.getCoordinate(xValue);
    var dataYCoord = yCoordinateCalculator.getCoordinate(yValue);
    var distance = (0, pointUtil_1.calcDistance)(xHitCoord, yHitCoord, dataXCoord, dataYCoord);
    return distance < hitTestRadius;
};
/**
 *
 * @param xCoordinateCalculator
 * @param yCoordinateCalculator
 * @param xValues
 * @param yValues
 * @param pointIndex
 * @param xHitCoord The X coordinate, isVertical property is already taken into account
 * @param yHitCoord The Y coordinate, isVertical property is already taken into account
 * @param hitTestRadius
 */
var testIsHitForLine = function (xCoordinateCalculator, yCoordinateCalculator, xValues, yValues, pointIndex, xHitCoord, yHitCoord, hitTestRadius) {
    var isHit;
    var secondPointIndex;
    var xLeft, xRight, yLeft, yRight;
    var isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
    var xValue = isCategoryAxis ? pointIndex : xValues.get(pointIndex);
    var yValue = yValues.get(pointIndex);
    var xHitValue = xCoordinateCalculator.getDataValue(xHitCoord);
    if (xValue <= xHitValue) {
        xLeft = xValue;
        yLeft = yValue;
        xRight = isCategoryAxis ? pointIndex + 1 : xValues.get(pointIndex + 1);
        yRight = yValues.get(pointIndex + 1);
        secondPointIndex = pointIndex + 1;
    }
    else {
        xLeft = isCategoryAxis ? pointIndex - 1 : xValues.get(pointIndex - 1);
        yLeft = yValues.get(pointIndex - 1);
        secondPointIndex = pointIndex - 1;
        xRight = xValue;
        yRight = yValue;
    }
    var xLeftCoord = xCoordinateCalculator.getCoordinate(xLeft);
    var xRightCoord = xCoordinateCalculator.getCoordinate(xRight);
    var yLeftCoord = yCoordinateCalculator.getCoordinate(yLeft);
    var yRightCoord = yCoordinateCalculator.getCoordinate(yRight);
    var lineSegmentLength = (0, pointUtil_1.calcDistance)(xLeftCoord, yLeftCoord, xRightCoord, yRightCoord);
    var distanceToLeftPoint = (0, pointUtil_1.calcDistance)(xLeftCoord, yLeftCoord, xHitCoord, yHitCoord);
    var distanceToRightPoint = (0, pointUtil_1.calcDistance)(xRightCoord, yRightCoord, xHitCoord, yHitCoord);
    // Because the line that goes through two points is infinite it could happen that mouse click is near this line
    // but far away from the line segment, especially if the segment is almost a vertical line
    // in this case we set isHit = false
    if (distanceToLeftPoint > lineSegmentLength + hitTestRadius ||
        distanceToRightPoint > lineSegmentLength + hitTestRadius) {
        isHit = false;
    }
    else {
        isHit =
            (0, pointUtil_1.calcDistanceFromLine)(xHitCoord, yHitCoord, xLeftCoord, yLeftCoord, xRightCoord, yRightCoord) <
                hitTestRadius;
    }
    return { isHit: isHit, secondPointIndex: secondPointIndex };
};
var testIsHitForBand = function (isDigitalLine, xCoordinateCalculator, yCoordinateCalculator, xValues, getYValue, getY1Value, pointIndex, xHitCoord, yHitCoord) {
    var isHit;
    var xHitValue = xCoordinateCalculator.getDataValue(xHitCoord);
    var isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
    var xValue = isCategoryAxis ? pointIndex : xValues.get(pointIndex);
    var isLeftHit = xValue <= xHitValue;
    var secondPointIndex = isLeftHit ? pointIndex + 1 : pointIndex - 1;
    if (secondPointIndex < 0 || secondPointIndex >= xValues.size()) {
        return { isHit: false, secondPointIndex: undefined };
    }
    var secondPointXValue = isCategoryAxis ? secondPointIndex : xValues.get(secondPointIndex);
    var xLeft = isLeftHit ? xValue : secondPointXValue;
    var yLeft = isLeftHit ? getYValue(pointIndex) : getYValue(secondPointIndex);
    var y1Left = isLeftHit ? getY1Value(pointIndex) : getY1Value(secondPointIndex);
    var xRight = isLeftHit ? secondPointXValue : xValue;
    var yRight = isLeftHit ? getYValue(secondPointIndex) : getYValue(pointIndex);
    var y1Right = isLeftHit ? getY1Value(secondPointIndex) : getY1Value(pointIndex);
    var xLeftCoord = xCoordinateCalculator.getCoordinate(xLeft);
    var xRightCoord = xCoordinateCalculator.getCoordinate(xRight);
    var yLeftCoord = yCoordinateCalculator.getCoordinate(yLeft);
    var yRightCoord = yCoordinateCalculator.getCoordinate(yRight);
    var y1LeftCoord = yCoordinateCalculator.getCoordinate(y1Left);
    var y1RightCoord = yCoordinateCalculator.getCoordinate(y1Right);
    if (isDigitalLine) {
        if (yLeftCoord < y1LeftCoord) {
            isHit = yHitCoord >= yLeftCoord && yHitCoord <= y1LeftCoord;
        }
        else {
            isHit = yHitCoord >= y1LeftCoord && yHitCoord <= yLeftCoord;
        }
    }
    else {
        var interpolatedLineY = interpolateLinear(xHitCoord, xLeftCoord, yLeftCoord, xRightCoord, yRightCoord);
        var interpolatedLineY1 = interpolateLinear(xHitCoord, xLeftCoord, y1LeftCoord, xRightCoord, y1RightCoord);
        if (interpolatedLineY < interpolatedLineY1) {
            isHit = yHitCoord >= interpolatedLineY && yHitCoord <= interpolatedLineY1;
        }
        else {
            isHit = yHitCoord >= interpolatedLineY1 && yHitCoord <= interpolatedLineY;
        }
    }
    return { isHit: isHit, secondPointIndex: secondPointIndex };
};
var testIsHitForColumn = function (xCoordinateCalculator, yCoordinateCalculator, renderableSeries, xValues, yValues, pointIndex, xHitCoord, yHitCoord) {
    var getDataPointWidth = renderableSeries.getDataPointWidth, dataPointWidth = renderableSeries.dataPointWidth, zeroLineY = renderableSeries.zeroLineY;
    var isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
    var xValue = isCategoryAxis ? pointIndex : xValues.get(pointIndex);
    var yValue = yValues.get(pointIndex);
    var xCoord = xCoordinateCalculator.getCoordinate(xValue);
    var yCoord = yCoordinateCalculator.getCoordinate(yValue);
    var columnWidth = getDataPointWidth(xCoordinateCalculator, dataPointWidth);
    var zeroLineYCoord = yCoordinateCalculator.getCoordinate(zeroLineY);
    var halfWidth = columnWidth / 2;
    var topColumnSide = zeroLineYCoord > yCoord ? zeroLineYCoord : yCoord;
    var bottomColumnSide = zeroLineYCoord > yCoord ? yCoord : zeroLineYCoord;
    return (0, pointUtil_1.testIsInBounds)(xHitCoord, yHitCoord, xCoord - halfWidth, topColumnSide, xCoord + halfWidth, bottomColumnSide);
};
var testIsHitForErrorBars = function (xCoordinateCalculator, yCoordinateCalculator, renderableSeries, xValues, yValues, pointIndex, xHitCoord, yHitCoord) {
    var getDataPointWidth = renderableSeries.getDataPointWidth, dataPointWidth = renderableSeries.dataPointWidth, errorDirection = renderableSeries.errorDirection;
    var isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
    var isVerticalDirection = errorDirection === ErrorDirection_1.EErrorDirection.Vertical;
    var xValue = isCategoryAxis ? pointIndex : xValues.get(pointIndex);
    var yValue = yValues.get(pointIndex);
    var highValue = renderableSeries.dataSeries.getNativeHighValues().get(pointIndex);
    var lowValue = renderableSeries.dataSeries.getNativeLowValues().get(pointIndex);
    if (isNaN(highValue))
        highValue = yValue;
    if (isNaN(lowValue))
        lowValue = yValue;
    var xCoord = xCoordinateCalculator.getCoordinate(xValue);
    var yCoord = yCoordinateCalculator.getCoordinate(yValue);
    var highCoord = isVerticalDirection
        ? yCoordinateCalculator.getCoordinate(highValue)
        : xCoordinateCalculator.getCoordinate(highValue);
    var lowCoord = isVerticalDirection
        ? yCoordinateCalculator.getCoordinate(lowValue)
        : xCoordinateCalculator.getCoordinate(lowValue);
    var columnWidth = getDataPointWidth(isVerticalDirection ? xCoordinateCalculator : yCoordinateCalculator, dataPointWidth);
    var halfWidth = columnWidth / 2;
    var isHit = false;
    var upperErrorBoundary = highCoord > lowCoord ? highCoord : lowCoord;
    var lowerErrorBoundary = highCoord > lowCoord ? lowCoord : highCoord;
    if (isVerticalDirection) {
        isHit = (0, pointUtil_1.testIsInBounds)(xHitCoord, yHitCoord, xCoord - halfWidth, upperErrorBoundary, xCoord + halfWidth, lowerErrorBoundary);
    }
    else {
        isHit = (0, pointUtil_1.testIsInBounds)(xHitCoord, yHitCoord, lowerErrorBoundary, yCoord + halfWidth, upperErrorBoundary, yCoord - halfWidth);
    }
    return { isHit: isHit, highValue: highValue, lowValue: lowValue };
};
var testIsHitForImpulse = function (xCoordinateCalculator, yCoordinateCalculator, renderableSeries, xValues, yValues, pointIndex, xHitCoord, yHitCoord, hitTestRadius) {
    var zeroLineY = renderableSeries.zeroLineY;
    var isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
    var xValue = isCategoryAxis ? pointIndex : xValues.get(pointIndex);
    var yValue = yValues.get(pointIndex);
    var xCoord = xCoordinateCalculator.getCoordinate(xValue);
    var yCoord = yCoordinateCalculator.getCoordinate(yValue);
    var zeroLineYCoord = yCoordinateCalculator.getCoordinate(zeroLineY);
    var topColumnSide = zeroLineYCoord > yCoord ? zeroLineYCoord : yCoord;
    var bottomColumnSide = zeroLineYCoord > yCoord ? yCoord : zeroLineYCoord;
    return (0, pointUtil_1.testIsInBounds)(xHitCoord, yHitCoord, xCoord, topColumnSide, xCoord, bottomColumnSide, hitTestRadius);
};
var testIsHitForOHLC = function (xCoordinateCalculator, yCoordinateCalculator, renderableSeries, dataSeries, pointIndex, xHitCoord, yHitCoord, hitTestRadius) {
    var getDataPointWidth = renderableSeries.getDataPointWidth, dataPointWidth = renderableSeries.dataPointWidth;
    var isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
    var xValue = isCategoryAxis ? pointIndex : dataSeries.getNativeXValues().get(pointIndex);
    var xCoord = xCoordinateCalculator.getCoordinate(xValue);
    var openValue = dataSeries.getNativeOpenValues().get(pointIndex);
    var openCoord = yCoordinateCalculator.getCoordinate(openValue);
    var highValue = dataSeries.getNativeHighValues().get(pointIndex);
    var highCoord = yCoordinateCalculator.getCoordinate(highValue);
    var lowValue = dataSeries.getNativeLowValues().get(pointIndex);
    var lowCoord = yCoordinateCalculator.getCoordinate(lowValue);
    var closeValue = dataSeries.getNativeCloseValues().get(pointIndex);
    var closeCoord = yCoordinateCalculator.getCoordinate(closeValue);
    var columnWidth = getDataPointWidth(xCoordinateCalculator, dataPointWidth);
    var halfWidth = columnWidth / 2;
    var topSide = closeCoord > openCoord ? closeCoord : openCoord;
    var bottomSide = closeCoord > openCoord ? openCoord : closeCoord;
    // test candle body
    var isCandleBodyHit = (0, pointUtil_1.testIsInBounds)(xHitCoord, yHitCoord, xCoord - halfWidth, topSide, xCoord + halfWidth, bottomSide);
    // test candle wicks
    var distanceToWicks = (0, pointUtil_1.calcDistanceFromLineSegment)(xHitCoord, yHitCoord, xCoord, highCoord, xCoord, lowCoord);
    var isHit = isCandleBodyHit || distanceToWicks < hitTestRadius;
    return { isHit: isHit, openValue: openValue, highValue: highValue, lowValue: lowValue, closeValue: closeValue };
};
var testIsHitForMountain = function (isDigitalLine, xCoordinateCalculator, yCoordinateCalculator, dataSeries, zeroLineY, pointIndex, xHitCoord, yHitCoord) {
    var isHit;
    var xValues = dataSeries.getNativeXValues();
    var isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
    var xValue = isCategoryAxis ? pointIndex : xValues.get(pointIndex);
    var yValues = dataSeries.getNativeYValues();
    var xHitValue = xCoordinateCalculator.getDataValue(xHitCoord);
    var isLeftHit = xValue <= xHitValue;
    var secondPointIndex = isLeftHit ? pointIndex + 1 : pointIndex - 1;
    if (secondPointIndex < 0 || secondPointIndex >= dataSeries.count()) {
        return { isHit: false, secondPointIndex: undefined };
    }
    var secondPointXValue = isCategoryAxis ? secondPointIndex : xValues.get(secondPointIndex);
    var xLeft = isLeftHit ? xValue : secondPointXValue;
    var yLeft = isLeftHit ? yValues.get(pointIndex) : yValues.get(secondPointIndex);
    var xRight = isLeftHit ? secondPointXValue : xValue;
    var yRight = isLeftHit ? yValues.get(secondPointIndex) : yValues.get(pointIndex);
    var xLeftCoord = xCoordinateCalculator.getCoordinate(xLeft);
    var xRightCoord = xCoordinateCalculator.getCoordinate(xRight);
    var yLeftCoord = yCoordinateCalculator.getCoordinate(yLeft);
    var yRightCoord = yCoordinateCalculator.getCoordinate(yRight);
    var zeroLineYCoord = yCoordinateCalculator.getCoordinate(zeroLineY);
    if (isDigitalLine) {
        if (yLeftCoord < zeroLineYCoord) {
            isHit = yHitCoord >= yLeftCoord && yHitCoord <= zeroLineYCoord;
        }
        else {
            isHit = yHitCoord >= zeroLineYCoord && yHitCoord <= yLeftCoord;
        }
    }
    else {
        var interpolatedLineY = interpolateLinear(xHitCoord, xLeftCoord, yLeftCoord, xRightCoord, yRightCoord);
        if (interpolatedLineY < zeroLineYCoord) {
            isHit = yHitCoord >= interpolatedLineY && yHitCoord <= zeroLineYCoord;
        }
        else {
            isHit = yHitCoord >= zeroLineYCoord && yHitCoord <= interpolatedLineY;
        }
    }
    return { isHit: isHit, secondPointIndex: secondPointIndex };
};
exports.hitTestHelpers = {
    createHitTestInfo: createHitTestInfo,
    getNearestXPoint: getNearestXPoint,
    getNearestXyPoint: getNearestXyPoint,
    getNearestXyyPoint: getNearestXyyPoint,
    getNearestUniformHeatmapPoint: getNearestUniformHeatmapPoint,
    getNearestNonUniformHeatmapPoint: getNearestNonUniformHeatmapPoint,
    testIsHitForPoint: testIsHitForPoint,
    testIsHitForLine: testIsHitForLine,
    testIsHitForBand: testIsHitForBand,
    testIsHitForColumn: testIsHitForColumn,
    testIsHitForOHLC: testIsHitForOHLC,
    testIsHitForMountain: testIsHitForMountain,
    testIsHitForErrorBars: testIsHitForErrorBars,
    testIsHitForImpulse: testIsHitForImpulse
};
